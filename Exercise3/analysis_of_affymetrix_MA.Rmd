---
title: "ANALYSIS OF AFFYMETRIX GENE MICROARRAYS"
author: "Mariona Alberola"
date: "31 de mayo de 2019"
output: html_document
---
## Summary	
UHRF1 is a major regulator of epigenetic mechanism and is overexpressed in various human malignancies. In this study, we examined the involvement of UHRF1 in aberrant DNA methylation in colorectal cancer (CRC). In CRC cells, transient UHRF1 knockdown rapidly induced DNA demethylation across entire genomic regions, including CpG islands, gene bodies and repetitive elements. Nonetheless, UHRF1 depletion only minimally reversed CpG island hypermethylation-associated gene silencing. However, the combination of UHRF1 depletion and histone deacetylase (HDAC) inhibition synergistically reactivated the silenced genes and strongly suppressed CRC cell proliferation. Our results suggest that (i) maintenance of DNA methylation in CRC cells is highly dependent on UHRF1; (ii) UHRF1 depletion rapidly induces DNA demethylation, though it is insufficient to fully reactivate the silenced genes; and (iii) dual targeting of UHRF1 and HDAC may be an effective new therapeutic strategy.
 	
## Overall design	
DLD1 cells were transfected with a control siRNA (Thermo Fisher Scientific) or siRNAs targeting UHRF1 (Thermo Fisher Scientific) using using Lipofectamine RNAiMAX (Thermo Fisher Scientific) and incubated for 48 h. Cells were then treated with mock (ethanol) or 300 nM Trichostatin A (TSA) for additional 24 h.
 	
## Contributor(s)	
Suzuki H

## Citation(s)	
Niinuma T, Kitajima H, Kai M, Yamamoto E et al. UHRF1 depletion and HDAC inhibition reactivate epigenetically silenced genes in colorectal cancer cells. Clin Epigenetics 2019 May 7;11(1):70. PMID: 31064417




```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

#---------------------------------------------------------------------------------------------
###FOLDER DESTINATION DEFINITIONS
#---------------------------------------------------------------------------------------------
```{r}
workingDir <-getwd()
dataDir <- file.path(workingDir, "dades")
resultsDir <- file.path(workingDir, "results")
setwd(resultsDir)
```

#---------------------------------------------------------------------------------------------
###INSTALLATION OF PACKAGES NEEDED
#---------------------------------------------------------------------------------------------
```{r}
if (!require(BiocManager)) install.packages("BiocManager")

installifnot <- function (pkg){
  if (!require(pkg, character.only=T)){
    BiocManager::install(pkg)
}else{
  require(pkg, character.only=T)
  }
}

installifnot("pd.mogene.1.0.st.v1")
installifnot("mogene10sttranscriptcluster.db")
installifnot("oligo")
installifnot("limma")
installifnot("Biobase")
installifnot("arrayQualityMetrics")
installifnot("genefilter")
installifnot("multtest")
installifnot("annotate")
installifnot("xtable")
installifnot("gplots")
installifnot("scatterplot3d")
```

#---------------------------------------------------------------------------------------------
###LOAD DATA: TARGETS AND CEL FILES. 
#---------------------------------------------------------------------------------------------
```{r}
#TARGETS
class(targets)
targets <-read.delim(file=file.path(dataDir,"targets.txt"), header = TRUE, sep= ";")
targets

#CELFILES
CELfiles <- list.celfiles(file.path(dataDir))
CELfiles
rawData <- read.celfiles(file.path(dataDir,CELfiles))

#DEFINE SOME VARIABLES FOR PLOTS
sampleNames <- as.character(targets$ShortName)
sampleColor <- as.character(targets$Colors)

```

#---------------------------------------------------------------------------------------------
###QUALITY CONTROL OF ARRAYS: RAW DATA
#---------------------------------------------------------------------------------------------

```{r}
#BOXPLOT
boxplot(rawData, which="all",las=2, main="Intensity distribution of RAW data", 
        cex.axis=0.6, col=sampleColor, names=sampleNames)

#HIERARQUICAL CLUSTERING
clust.euclid.average <- hclust(dist(t(exprs(rawData))),method="average")
plot(clust.euclid.average, labels=sampleNames, main="Hierarchical clustering of RawData", 
     cex=0.7,  hang=-1)

#PRINCIPAL COMPONENT ANALYSIS
plotPCA <- function ( X, labels=NULL, colors=NULL, dataDesc="", scale=FALSE, formapunts=NULL, myCex=0.8,...)
{
  pcX<-prcomp(t(X), scale=scale) # o prcomp(t(X))
  loads<- round(pcX$sdev^2/sum(pcX$sdev^2)*100,1)
  xlab<-c(paste("PC1",loads[1],"%"))
  ylab<-c(paste("PC2",loads[2],"%"))
  if (is.null(colors)) colors=1
  plot(pcX$x[,1:2],xlab=xlab,ylab=ylab, col=colors, pch=formapunts, 
       xlim=c(min(pcX$x[,1])-100000, max(pcX$x[,1])+100000),ylim=c(min(pcX$x[,2])-100000, max(pcX$x[,2])+100000))
  text(pcX$x[,1],pcX$x[,2], labels, pos=3, cex=myCex)
  title(paste("Plot of first 2 PCs for expressions in", dataDesc, sep=" "), cex=0.8)
}

plotPCA(exprs(rawData), labels=sampleNames, dataDesc="raw data", colors=sampleColor,
        formapunts=c(rep(16,4),rep(17,4)), myCex=0.6)

#SAVE TO A FILE
pdf(file.path(resultsDir, "QCPlots_Raw.pdf"))
boxplot(rawData, which="all",las=2, main="Intensity distribution of RAW data", 
        cex.axis=0.6, col=sampleColor, names=sampleNames)
plot(clust.euclid.average, labels=sampleNames, main="Hierarchical clustering of samples of RawData", 
     cex=0.7,  hang=-1)
plotPCA(exprs(rawData), labels=sampleNames, dataDesc="raw data", colors=sampleColor,
        formapunts=c(rep(16,4),rep(17,4)), myCex=0.6)
dev.off()
```

#---------------------------------------------------------------------------------------------
###DATA NORMALIZATION
#---------------------------------------------------------------------------------------------
```{R}
eset<-rma(rawData)

write.exprs(eset, file.path(resultsDir, "NormData.txt"))
```

#---------------------------------------------------------------------------------------------
###QUALITY CONTROL OF ARRAYS: NORMALIZED DATA
#---------------------------------------------------------------------------------------------
```{r}
#BOXPLOT
boxplot(eset, las=2, main="Intensity distribution of Normalized data", cex.axis=0.6, 
        col=sampleColor, names=sampleNames)

#HIERARQUICAL CLUSTERING
clust.euclid.average <- hclust(dist(t(exprs(eset))),method="average")
plot(clust.euclid.average, labels=sampleNames, main="Hierarchical clustering of NormData", 
     cex=0.7,  hang=-1)

#PRINCIPAL COMPONENT ANALYSIS
plotPCA <- function ( X, labels=NULL, colors=NULL, dataDesc="", scale=FALSE, formapunts=NULL, myCex=0.8,...)
{
  pcX<-prcomp(t(X), scale=scale) # o prcomp(t(X))
  loads<- round(pcX$sdev^2/sum(pcX$sdev^2)*100,1)
  xlab<-c(paste("PC1",loads[1],"%"))
  ylab<-c(paste("PC2",loads[2],"%"))
  if (is.null(colors)) colors=1
  plot(pcX$x[,1:2],xlab=xlab,ylab=ylab, col=colors, pch=formapunts, 
       xlim=c(min(pcX$x[,1])-10, max(pcX$x[,1])+10),ylim=c(min(pcX$x[,2])-10, max(pcX$x[,2])+10))
  text(pcX$x[,1],pcX$x[,2], labels, pos=3, cex=myCex)
  title(paste("Plot of first 2 PCs for expressions in", dataDesc, sep=" "), cex=0.8)
}

plotPCA(exprs(eset), labels=sampleNames, dataDesc="NormData", colors=sampleColor,
        formapunts=c(rep(16,4),rep(17,4)), myCex=0.6)

#SAVE TO A FILE
pdf(file.path(resultsDir, "QCPlots_Norm.pdf"))
boxplot(eset, las=2, main="Intensity distribution of Normalized data", cex.axis=0.6, 
        col=sampleColor, names=sampleNames)
plot(clust.euclid.average, labels=sampleNames, main="Hierarchical clustering of NormData", 
     cex=0.7,  hang=-1)
plotPCA(exprs(eset), labels=sampleNames, dataDesc="selected samples", colors=sampleColor,
        formapunts=c(rep(16,4),rep(17,4)), myCex=0.6)
dev.off()

#ARRAY QUALITY METRICS
arrayQualityMetrics(eset,  reporttitle="QualityControl", force=TRUE)
```

#---------------------------------------------------------------------------------------------
###FILTER OUT THE DATA
#---------------------------------------------------------------------------------------------
```{r}
annotation(eset) <- "org.Mm.eg.db"
eset_filtered <- nsFilter(eset, var.func=IQR,
         var.cutoff=0.75, var.filter=TRUE,
         filterByQuantile=TRUE)
#NUMBER OF GENES OUT
print(eset_filtered$filter.log$numLowVar)

#NUMBER OF GENES IN
print(eset_filtered$eset)
```

#---------------------------------------------------------------------------------------------
###DIFERENTIAL EXPRESSED GENES SELECTION. LINEAR MODELS. COMPARITIONS
#---------------------------------------------------------------------------------------------
```{r}
#CONTRAST MATRIX.lINEAR MODEL
treat <- targets$grupos
lev <- factor(treat, levels = unique(treat))
design <-model.matrix(~0+lev)
colnames(design) <- levels(lev)
rownames(design) <- sampleNames
print(design)

#COMPARISON
cont.matrix1 <- makeContrasts( 
        Induced.vs.WT = Induced-WT,
        levels = design)
comparison1 <- "Effect of Induction"

#MODEL FIT
fit1 <- lmFit(eset_filtered$eset, design)
fit.main1 <- contrasts.fit(fit1, cont.matrix1)
fit.main1 <- eBayes(fit.main1)
```

#---------------------------------------------------------------------------------------------
###DIFERENTIAL EXPRESSED GENES LISTS.TOPTABLES
#---------------------------------------------------------------------------------------------
```{r}

#FILTER BY FALSE DISCOVERY RATE AND FOLD CHANGE
topTab <-  topTable (fit.main1, number=nrow(fit.main1), coef="Induced.vs.WT", adjust="fdr",lfc=abs(3))

#EXPORTED TO CSV AND HTML FILE
write.csv2(topTab, file= file.path(resultsDir,paste("Selected.Genes.in.comparison.",
                                                    comparison1, ".csv", sep = "")))

print(xtable(topTab,align="lllllll"),type="html",html.table.attributes="",
      file=paste("Selected.Genes.in.comparison.",comparison1,".html", sep=""))

```
#---------------------------------------------------------------------------------------------
###VOLCANO PLOTS
#---------------------------------------------------------------------------------------------
```{r}
volcanoplot(fit.main1, highlight=10, names=fit.main1$ID, 
            main = paste("Differentially expressed genes", colnames(cont.matrix1), sep="\n"))
abline(v = c(-3, 3))


pdf(file.path(resultsDir,"Volcanos.pdf"))
volcanoplot(fit.main1, highlight = 10, names = fit.main1$ID, 
            main = paste("Differentially expressed genes", colnames(cont.matrix1), sep = "\n"))
abline(v = c(-3, 3))
dev.off()
```

#---------------------------------------------------------------------------------------------
###HEATMAP PLOTS
#---------------------------------------------------------------------------------------------
```{r}
#PREPARE THE DATA
my_frame <- data.frame(exprs(eset))
head(my_frame)
HMdata <- merge(my_frame, topTab, by.x = 0, by.y = 0)
rownames(HMdata) <- HMdata$Row.names
HMdata <- HMdata[, -c(1,10:15)]
head(HMdata)
HMdata2 <- data.matrix(HMdata, rownames.force=TRUE)
head(HMdata2)
write.csv2(HMdata2, file = file.path(resultsDir,"Data2HM.csv"))

#HEATMAP PLOT
my_palette <- colorRampPalette(c("blue", "red"))(n = 299)

heatmap.2(HMdata2,
          Rowv=TRUE,
          Colv=TRUE,
          main="HeatMap Induced.vs.WT FC>=3",
          scale="row",
          col=my_palette,
          sepcolor="white",
          sepwidth=c(0.05,0.05),
          cexRow=0.5,
          cexCol=0.9,
          key=TRUE,
          keysize=1.5,
          density.info="histogram",
          ColSideColors=c(rep("red",4),rep("blue",4)),
          tracecol=NULL,
          srtCol=30)

#EXPORT TO PDF FILE
pdf(file.path(resultsDir,"HeatMap InducedvsWT.pdf"))
heatmap.2(HMdata2,
          Rowv=TRUE,
          Colv=TRUE,
          main="HeatMap Induced.vs.WT FC>=3",
          scale="row",
          col=my_palette,
          sepcolor="white",
          sepwidth=c(0.05,0.05),
          cexRow=0.5,
          cexCol=0.9,
          key=TRUE,
          keysize=1.5,
          density.info="histogram",
          ColSideColors=c(rep("red",4),rep("blue",4)),
          tracecol=NULL,
          srtCol=30)
dev.off()
```
#---------------------------------------------------------------------------------------------
###DATA ANNOTATION
#---------------------------------------------------------------------------------------------
```{r}
all_anota<-data.frame(exprs(eset))
Annot <- data.frame(SYMBOL=sapply(contents(mogene10sttranscriptclusterSYMBOL), paste, collapse=", "),
                    DESC=sapply(contents(mogene10sttranscriptclusterGENENAME), paste, collapse=", "))
Annot<-Annot[!Annot$SYMBOL=="NA",]
Annot<-Annot[!Annot$DESC=="NA",]
head(Annot)

anotaGenes <- merge(Annot,all_anota, by.x=0,by.y=0)
head(anotaGenes)
write.table(anotaGenes, file ="data.ann.txt",sep="\t")

rownames(anotaGenes) <- anotaGenes[,1]
anotaGenes <- anotaGenes[,-1]
anotaGenes.end <- merge(anotaGenes, topTab, by.x=0,by.y=0)
#reordenamos las columnas
topTab.end <- anotaGenes.end[,c(1:3,12:17,4:11)]
topTab.end <- topTab.end[order(-topTab.end$B),]

rownames(topTab.end) <- topTab.end[,1]
topTab.end <- topTab.end[, -1]
write.csv(topTab.end, file = file.path(resultsDir,"TopTable.end.csv"))
```
#---------------------------------------------------------------------------------------------
#END OF SCRIPT
#---------------------------------------------------------------------------------------------
```{R}
require(hgu133a.db)
columns(hgu133a.db)


```

